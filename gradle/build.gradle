import groovy.json.*
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

plugins {
  id "de.undercouch.download" version "3.4.3"
}

def slurper = new JsonSlurper()

def ensure_property(def obj, String keyname, List candidates, Integer default_value_index = 0)
{
  if(!obj.hasProperty(keyname)) {
    obj.metaClass.setProperty(keyname, candidates[default_value_index])
  }

  assert(candidates.contains(obj.getProperty(keyname)))
}

def build_configs = ["Debug", "Release", "MinSizeRel", "RelWithDebInfo"]

// Property about build configuration
ensure_property(project, "config", build_configs)
// Property about ccache.
// (note: ccache is not used if not installed even if this property is true.)
ensure_property(project, "use_ccache", ["true", "false"])
// build libraries even if cache archives are available.
ensure_property(project, "renew_cache", ["false", "true"])

ensure_property(project, "msvc_version", ["Visual Studio 16 2019", "Visual Studio 15 2017"])

// enable setting cache title to distiguish stored caches with titles.
if(project.hasProperty("cache_title") == false) {
  project.metaClass.setProperty("cache_title", "")
}

project.cache_title = project.cache_title.trim().replaceAll(/ /, "_")

ext {
  isWindows = { return System.properties['os.name'].toLowerCase().startsWith("windows") }
  get_build_dir_name = { conf -> return "build_${conf.toLowerCase()}" }
  build_dir_name = get_build_dir_name(project.config)
  enable_ccache = ((project.use_ccache == "true" && isWindows() == false) ? "which ccache".execute().waitFor() == 0 : false)
  ccache_path = (enable_ccache ? "which ccache".execute().text.trim() : "")
  ccache_envvars = (enable_ccache ? [CC: "${ccache_path} clang", CXX: "${ccache_path} clang++"] : [CCACHE_DISABLE: "true"])
  should_renew_cache = (project.renew_cache == "true")
  install_target = isWindows() ? "INSTALL" : "install"
  all_build_target = isWindows() ? "ALL_BUILD" : "all"
  parallel_option = "-j ${Runtime.getRuntime().availableProcessors() + 1}"
  getCMakeGenerator = {
    return isWindows() ? "-G \"${project.msvc_version}\" -A x64" : "-G Xcode"
  }
  getCMakeGeneratorForSubmodule = {
    return isWindows() ? "-G \"${project.msvc_version}\" -A x64" : "-G \"Unix Makefiles\""
  }
  collect_files = { def dir, def pattern ->
    def tmp = []
    file(dir).eachDirMatch(pattern) { tmp << it }
    return tmp
  }

  chapters = collect_files("..", ~/^Chapter.*$/)
}

//! @param options is a map to customize getenv behavior.
//! these options are supported.
//! * null_as_empty. (Boolean, default is false)
//! * trim. (Boolean. default is false)
def getenv = { String key, Map options = [:] ->
  def tmp = java.lang.System.getenv()[key]
  if(options["null_as_empty"]) {
    if(tmp == null) { tmp = "" }
  }

  if(options["trim"]) {
    tmp = tmp.trim()
  }
}

// 渡された文字列を空白で区切って、単語のリストとして返す。
// ただし、引用符(`'` or `"`)で囲まれた範囲は空白で区切らずに、ひと続きの文字列とみなす
// 引用符で囲まれた範囲内であっても、`\"`のようにエスケープされているものや、
// 引用符の種類が異なるものは引用符の終わりとはみなさない。
// ex) tokenize(/abc def "ghi \"jkl ' mno" pqr/) => [abc, def, "ghi \"jkl ' mno", pqr]
// @return [
//    tokens: <tokenized string list if succeeded, [] otherwise>,
//    error: <error msg if something failed, "" otherwise.>
// ]
def tokenize_with_error(String src)
{
  logger.info("start tokenize: ${src}")

  def separator_char = ' '
  def escape_char = '\\'
  def quote_chars = [/'/, /"/]

  String token = ""
  def output = []
  def is_escaped = false
  def found_quote = ""
  def quoted = { found_quote != "" }

  src.each { it ->
    logger.debug("it: ${it}")

    if(quoted()) {
      if(is_escaped) {
        is_escaped = false
        logger.debug("\t--1")
      } else if(it == escape_char) {
        is_escaped = true
        logger.debug("\t--2")
      } else if(it == found_quote) {
        found_quote = ""
        logger.debug("\t--3")
        return
      }
    } else {
      if(quote_chars.contains(it)) {
        found_quote = it
        logger.debug("\t--4")
        return
      } else if(it == separator_char) {
        if(token != "") {
          logger.debug("\t--5")
          output << token
          token = ""
        }
        return
      }
    }

    token += it
  }

  if(quoted()) {
    return [ tokens: [], error: "quotation is not closed." ]
  }

  if(token != "") { output << token }
  return [ tokens: output, error: "" ]
}

def tokenize(String str)
{
  def result = tokenize_with_error(str)
  assert(result.error == "")
  return result.tokens
}

task test_tokenize {
  def is_failed = false
  def fail = { String msg ->
    logging.error(msg)
    is_failed = true
  }
  def test = { String str, List expected ->
    def result = tokenize_with_error(str)
    if(result.tokens != expected) {
      fail("given:[${str}], expected:${expected}, but:" + result.tokens)
    }
  }
  doLast {
    test("", [])
    test("abc", ["abc"])
    test(/"abc"/, [/"abc"/])
    test('abc def', ["abc", "def"])
    test("abc'def", [])            // error: /'/ is not closed.
    test('abc"def', [])            // error: /"/ is not closed.
    test($/abc"def\"/$, [])        // error: /"/ is not closed because escaped.
    test("abc'def'", ["abc'def'"])
    test("abc 'def ghi'", ["abc", "'def ghi'"])
    test("abc'def ghi'", ["abc'def ghi'"])
    test($/abc 'def" ghi'/$, ["abc", $/'def" ghi'/$]) // /"/ can be placed and no need to be closed in /'/ pair
    test($/abc "def\" 'ghi jkl'"/$, ["abc", $/"def\" 'ghi jkl'"/$])

    if(is_failed) { assert false, "[FAILED]" } else { println "[PASS]" }
  }

  description = """test tokenize() function"""
}

class ExecutionResult
{
  def ExecutionResult(int exit_value, String text, String error_text)
  {
    this.exit_value = exit_value
    this.text = text
    this.error_text = error_text
  }

  int exitValue() { return exit_value }
  boolean succeeded() { return exit_value == 0 }
  boolean failed() { return exit_value != 0 }

  String getText() { return text }
  String getErrorText() { return error_text }

  int exit_value
  String text
  String error_text
}

//! execute specified command and wait for finish the execution.
//! @param command is a string consists of executable command and its parameters.
//! @param working_dir is the working directory for the executable.
//! @param env_vars is environment variables as a list of key:value pair. this parameter may be nil.
def execute_may_fail = { String command, def working_dir = ".", Map env_vars = [:] ->
  if(isWindows()) {
    command = "cmd /c chcp 65001 > nul & " + command.toString()
  }

  def tmp = tokenize(command)
  println "${tmp} @ '${working_dir}' (${env_vars})"

  def pb = new ProcessBuilder(tokenize(command))
  pb.directory(file(working_dir).getAbsoluteFile())

  if(env_vars) {
    def pb_env = pb.environment()
    env_vars.each { key, value -> pb_env.put(key, value) }
  }

  def process = pb.start()
  String text = ""
  String error_text = ""

  def service = Executors.newCachedThreadPool()

  // these outputs may be displayed earlier than the outputs of main thread.
  service.execute {
    process.in.eachLine { line ->
      text += line + "\n"
      System.out.&println line
    }
  }

  // these outputs may be displayed earlier than the outputs of main thread.
  service.execute {
    process.err.eachLine { line ->
      error_text += line + "\n"
      System.err.&println line
    }
  }

  process.waitFor()

  service.shutdown()
  service.awaitTermination(1, TimeUnit.MINUTES)

  return new ExecutionResult(process.exitValue(), text, error_text)
}

//! similar to execute_may_fail but this function fails if the command finished with an exit value of non zero.
def execute = { String params, def working_dir = ".", Map env_vars = [:] ->
  def result = execute_may_fail(params, working_dir, env_vars)
  assert result.succeeded(), "undesirable exit value ${result.exitValue()}"
  return result
}

task update_submodules {
  group = "other"
  doLast {
    execute("git submodule update --init --recursive", "..")
  }
}

// 指定したディレクトリが存在しなければ作成し、成功か失敗かをbooleanで返す
// 存在する場合は何もせずにtrueを返す
def mkdirs_if_needed = { def path ->
  def f = file(path)
  if(f.exists()) { return true }

  return f.mkdirs()
}

def createCacheParam = { File cache_dir, String archive_name, String build_config, String hash ->
  def getOsName = { return isWindows() ? "win" : "mac" }
  return [
    getOsName: getOsName,
    cache_dir: cache_dir,
    archive_name: archive_name,
    build_config: build_config,
    hash: hash,
    getArchiveFileName: {
      def name = project.cache_title
      if(name != "") { name += "_" }
      name += "${archive_name}_${getOsName()}_${build_config}_${hash}.tar.gz"
      assert(name.contains(" ") == false)
      return name
    }
  ]
}

// interface CacheStrategy
// {
//   boolean fetch(def param)
//   boolean store(def param)
// }

def createNullCacheStrategy = {
  logger.info("create NullCacheStrategy object")
  return [
    fetch: { def param -> return false },
    store: { def param -> return false },
  ]
}

def createAzureCacheStrategy = {
  logger.info("create AzureCacheStrategy object")
  def getAzureStorageAccount = {
    return getenv("AZURE_STORAGE_ACCOUNT", [null_as_empty: true, trim: true])
  }

  def getAzureStorageKey = {
    return getenv("AZURE_STORAGE_KEY", [null_as_empty: true, trim: true])
  }

  def getAzureStorageContainerName = {
    return getenv("AZURE_STORAGE_CONTAINER_NAME", [null_as_empty: true, trim: true])
  }

  def getBlobApiParams = {
    return  " --container-name ${getAzureStorageContainerName()} "
    +       " --storage-account ${getAzureStorageAccount()} "
    +       " --storage-key ${getAzureStorageKey()} "
  }

  def isCached = { def param ->
    def result = execute_may_fail(
      " az storage blob exists ${getBlobApiParams()} "
      + " --name ${param.getArchiveFileName()} "
      )

    if(result.failed()) {
      logger.warn("failed to check the blob existence")
      return false
    }

    def blob_exists_result = slurper.parseText(result.text)
    assert blob_exists_result

    if(blob_exists_result.exists == false) {
      return false
    }
  }

  if(isWindows()) {
    if(execute_may_fail("where az").failed()) { return null }
  } else {
    if(execute_may_fail("which az").failed()) { return null }
  }

  if(getAzureStorageAccount() == ""
     || getAzureStorageKey() == ""
     || getAzureStorageContainerName() == "")
   {
      logger.info("azure settings not found")
      return null
   }


  return [
    fetch: { def param ->
      if(isCached(param) == false) {
        return false
      }

      if(mkdirs_if_needed(param.cache_dir) == false) {
        assert false, "failed to create ${param.cache_dir}"
      }

      def result = execute_may_fail(
        " az storage blob download ${getBlobApiParams()} "
        + " --name ${param.getArchiveFileName()} "
        + " --file ${param.getArchiveFileName()} "
        , param.cache_dir)

      if(result.failed()) {
        logger.warn("failed to download the blob")
        return false
      }

      // extract archive
      result = execute_may_fail(
        "tar -xvf ${param.getArchiveFileName()}"
        , param.cache_dir)

      // remove downloaded archive
      execute("rm '${param.getArchiveFileName()}'", param.cache_dir)

      if(result.failed()) {
        logger.warn("failed extract ${param.getArchiveFileName()}")
        return false
      }

      return true
    },
    store: { def param ->
      assert(file(param.cache_dir).exists())

      if(isWindows()) {
        def tar_result = execute_may_fail(
            "tar --warning=no-file-changed -cjvhf ${param.getArchiveFileName()} ./"
            , param.cache_dir)

        if(tar_result.exitValue() >= 2) {
          logger.warn("failed to create archive.")
          return false
        }
      } else {
        execute("tar -cjvhf ${param.getArchiveFileName()} ./", param.cache_dir)
      }

      def result = execute_may_fail(
        " az storage blob upload "
        + " ${getBlobApiParams()} "
        + " --name ${param.getArchiveFileName()} "
        + " --file ${param.getArchiveFileName()} "
        , param.cache_dir)

      execute("rm '${param.getArchiveFileName()}'", param.cache_dir)

      if(result.failed()) {
        logger.warn("failed to upload cache")
        return false
      }

      return true
    },
    isCached: isCached,
  ]
}

def get_hash = { String submodule_name ->
  def result = execute("git rev-parse HEAD", file("../ext/${submodule_name}"))
  return result.text.trim()
}

def get_cache_strategy = {
  def st = createAzureCacheStrategy()
  if(st) {
    println "Use AzureCacheStrategy"
  }

  if(st == null) {
    st = createNullCacheStrategy()
    println "Use NullCacheStrategy"
  }

  return st
}

// 指定したディレクトリのキャッシュが有効なときはそれを使用し、
// キャッシュがないときはビルドを行う
def build_if_needed = { String archive_name, File cache_dir, String hash, Closure do_build ->
  def cache = get_cache_strategy()
  def param = createCacheParam(cache_dir, archive_name, project.config, hash)

  if(should_renew_cache) {
    println "Renew cache"
  } else {
    // fetchしたデータの正当性は確認しない
    // （正当性を確認して、内容が不十分なときはdo_buildでビルドし直すような設計も考えられるが、
    // do_buildの実装側が面倒になるので、そこまではしない）
    def fetched = cache.fetch(param)
    if(fetched) { return }
  }

  do_build()
  def result = cache.store(param)
  if(result == false) {
    logger.warn("Failed to store cache")
  }
}

task build_rtmidi {
  group = "build"
  doLast {
    println "Build RtMidi"
    def build_dir = file("../ext/rtmidi/${build_dir_name}").getAbsolutePath()
    assert(mkdirs_if_needed(build_dir))

    build_if_needed(
      "rtmidi",
      file("${build_dir}/install"),
      get_hash("rtmidi"),
      {
        execute("cmake ${getCMakeGeneratorForSubmodule()} -DCMAKE_INSTALL_PREFIX=\"${build_dir}/install\" -DBUILD_SHARED_LIBS=OFF -DBUILD_TESTING=OFF ..", build_dir, ccache_envvars)
        execute("cmake --build . ${parallel_option} --target ${all_build_target} --config ${project.config}", build_dir, ccache_envvars)
        execute("cmake --build . ${parallel_option} --target ${install_target} --config ${project.config}", build_dir)
      })
  }
}
build_rtmidi.mustRunAfter update_submodules

task build_portaudio {
  group = "build"
  doLast {
    println "Build PortAudio"
    def build_dir = file("../ext/portaudio/${build_dir_name}").getAbsolutePath()
    assert(mkdirs_if_needed(build_dir))

    build_if_needed(
      "portaudio",
      file("${build_dir}/install"),
      get_hash("portaudio"),
      {
        if(isWindows()) {
          def asiosdk_zip_name = "asiosdk2.3.zip"
          def asiosdk_zip_path = new File(build_dir, asiosdk_zip_name)
          def asiosdk_url = "https://www.steinberg.net/sdk_downloads/${asiosdk_zip_name}"
          def asiosdk_dir = new File(build_dir, "ASIOSDK2.3")

          download {
            src asiosdk_url
            dest build_dir
            overwrite false
          }
          assert(asiosdk_zip_path.exists())

          copy {
            from zipTree(asiosdk_zip_path)
            into build_dir
          }
        }

        execute("cmake ${getCMakeGeneratorForSubmodule()} -DCMAKE_INSTALL_PREFIX=\"${build_dir}/install\" " +
                " -DCMAKE_BUILD_TYPE=${project.config} " +
                "-DPA_BUILD_STATIC=ON -DPA_DLL_LINK_WITH_STATIC_RUNTIME=OFF -DPA_BUILD_SHARED=OFF " +
                " ${isWindows() ? "-DPA_USE_WDMKS=OFF -DPA_USE_ASIO=ON -DASIOSDK_ROOT_DIR=\"${asiosdk_dir}\"" : ""} " +
                "..",
                build_dir)
        execute("cmake --build . ${parallel_option} --target ${all_build_target} --config ${project.config}", build_dir)
        execute("cmake --build . ${parallel_option} --target ${install_target} --config ${project.config}", build_dir)
      })
  }
}
build_portaudio.mustRunAfter update_submodules


task build_vst3sdk {
  group = "build"
  doLast {
    println "Build VST3 SDK"
    def build_dir = file("../ext/vst3sdk/${build_dir_name}").getAbsolutePath()
    assert(mkdirs_if_needed(build_dir))

    build_if_needed(
      "vst3sdk",
      file(build_dir),
      get_hash("vst3sdk"),
      {
        // VST3SDKは、makeのinstallターゲットを用意しない
        execute(
          " cmake ${getCMakeGeneratorForSubmodule()} -DCMAKE_BUILD_TYPE=${project.config} " +
          " -DCMAKE_INSTALL_PREFIX='${build_dir}/install' " +
          " -DSMTG_ADD_VST3_PLUGINS_SAMPLES=OFF " +
          " -DSMTG_ADD_VST3_HOSTING_SAMPLES=OFF " +
          " -DSMTG_ADD_VSTGUI=OFF " +
          ".."
          , build_dir)
        execute("cmake --build . ${parallel_option} --target ${all_build_target} --config ${project.config}", build_dir, ccache_envvars)
      })
  }
}
build_vst3sdk.mustRunAfter update_submodules

task build_wxwidgets {
  group = "build"
  doLast {
    println "Build wxWidgets"
    def build_dir = file("../ext/wxWidgets/${build_dir_name}").getAbsolutePath()
    assert(mkdirs_if_needed(build_dir))

    build_if_needed(
      "wxwidgets",
      file("${build_dir}/install"),
      get_hash("wxWidgets"),
      {
        def platform_dir = isWindows() ? "msw" : "osx"
        if(isWindows()) {
          copy {
            from file("../ext/wxWidgets/include/wx/msw/setup0.h")
            into file("../ext/wxWidgets/include/wx/msw")
            rename "setup0\\.h", "setup.h"
          }
          execute("cmake ${getCMakeGenerator()} -DCMAKE_INSTALL_PREFIX='${build_dir}/install' " +
                  " -DwxBUILD_SHARED=OFF -DwxBUILD_MONOLITHIC=OFF " +
                  "-DwxBUILD_USE_STATIC_RUNTIME=OFF -DwxBUILD_MSVC_MULTIPROC=ON " +
                  "-DCMAKE_CXX_STANDARD=14 .."
                  , build_dir)
          execute("cmake --build . ${parallel_option} --target ALL_BUILD --config ${project.config}", build_dir)
          execute("cmake --build . ${parallel_option} --target INSTALL --config ${project.config}", build_dir)
        } else {
          def debug_flags = ""
          if(project.config == "Debug") {
            debug_flags = "--enable-debug --enable-debug-info --enable-debug-gdb"
          }

          // wxWidgetsをCMakeでビルドした場合は、wx-configが正しく設定されずリンクオプションが不十分な状態になるようなので、
          // 旧来通りの方法としてconfigureスクリプトとmakeを使用するようにしている。
          execute("./autogen.sh", "../ext/wxWidgets")
          execute('../configure CXXFLAGS="-stdlib=libc++ -DHAVE_TYPE_TRAITS" OBJCXXFLAGS="-stdlib=libc++" ' +
                  'CPPFLAGS="-stdlib=libc++" LDFLAGS="-stdlib=libc++" ' +
                  '--with-macosx-version-min=10.9 --with-cocoa ' +
                  '--with-libjpeg=builtin --with-libpng=builtin --with-regex=builtin --with-libtiff=builtin ' +
                  '--with-zlib=builtin --with-expat=builtin ' +
                  "--disable-shared --enable-unicode ${debug_flags} --with-cxx=14 --prefix=\"${build_dir}/install\"",
                  build_dir,
                  ccache_envvars
                  )
          execute("make ${parallel_option}", build_dir, ccache_envvars)
          execute("make install", build_dir)
        }
      })
  }
}
build_wxwidgets.mustRunAfter update_submodules

task build_submodules {
  group = "build"
  dependsOn { [build_rtmidi, build_portaudio, build_vst3sdk, build_wxwidgets] }
}

task copy_resources {
  group = "other"
  doLast {
    // there is no need to copy resources with this task on macOS,
    // because the resources are copied into a bundle directory by cmake script.
    if(isWindows() == false) { return; }

    chapters.each { ch ->
      def lch = ch.toLowerCase()
      def src = file("../data")
      def app_output_dir = file("../${build_dir_name}/${ch}/${project.config}").getAbsolutePath()
      def test_output_dir = file("../${build_dir_name}/${ch}-Test/${project.config}").getAbsolutePath()

      [app_output_dir, test_output_dir].each { dir ->
        def dest = new File(dir, "Resource")
        assert(mkdirs_if_needed(dir))
        copy {
          from src
          into dest
        }
      }
    }
  }

  description = """copy resource data into the output directory."""
}

task prepare_project {
  group = "build"
  doLast {
    def build_dir = file("../${build_dir_name}").getAbsolutePath()
    assert(mkdirs_if_needed(build_dir))
    execute("cmake ${getCMakeGenerator()} -DCMAKE_CONFIGURATION_TYPES=Debug ..", build_dir, ccache_envvars)
  }
}
prepare_project.mustRunAfter build_submodules

//! 指定したディレクトリの直下にあるディレクトリのうち、
//! 現在のビルド構成によって決まるディレクトリ名と同じディレクトリがあれば、それを削除する。
def delete_build_dir(def target_dir, def dir_name) {
  def target_path = new File(target_dir, dir_name)
  if(target_path.exists()) {
    println "dir path to delete: '${target_path}'"
    target_path.deleteDir()
  }
}

task clean_submodules {
  group = "clean"
  doLast {
    file("../ext").eachDir {
      delete_build_dir(it, build_dir_name)
    }
  }
}

task clean_project {
  group = "clean"
  doLast {
    delete_build_dir("..", build_dir_name)
  }
}

def build_app_tasks = []
def build_test_tasks = []
def run_test_tasks = []

chapters.each { ch ->
  ch = ch.getName()
  def lch = ch.toLowerCase()
  // generatorがXcodeのときは不要
  task "build_app_${lch}" {
    group = "build"
    doLast {
      def build_dir = file("../${build_dir_name}").getAbsolutePath()
      execute("cmake --build . ${parallel_option} --target ${ch} --config ${project.config}", build_dir, ccache_envvars)
    }
  }

  task "build_test_${lch}" {
    group = "build"
    doLast {
      // test project must be built with Debug configuration
      assert(project.config == "Debug")

      def build_dir = file("../${build_dir_name}").getAbsolutePath()
      execute("cmake --build . ${parallel_option} --target ${ch}-Test --config ${project.config}", build_dir)
    }
  }

  task "run_app_${lch}" {
    group = "run"
    doLast {
      def build_dir = file("../${build_dir_name}").getAbsolutePath()
      def executable_path = ""
      if(isWindows()) {
        executable_path = file(".\\${build_dir_name}\\${project.config}\\${ch}\\Vst3SampleHost.exe")
      } else {
        executable_path = file("./${build_dir_name}/${project.config}/${ch}/Vst3SampleHost.app")
      }
      execute("${executable_path}", build_dir)
    }
  }

  task "run_test_${lch}" {
    group = "run"
    doLast {
      assert(project.config == "Debug")

      def build_dir = file("../${build_dir_name}").getAbsolutePath()
      def executable_path = ""
      if(isWindows()) {
        executable_path = file(".\\${build_dir_name}\\${project.config}\\${ch}-Test\\Vst3SampleHost-Test.exe")
      } else {
        executable_path = file("./${build_dir_name}/${project.config}/${ch}-Test/Vst3SampleHost-Test.app/Contents/MacOS/Vst3SampleHost-Test")
      }
      execute("${executable_path}", build_dir)
    }
  }

  tasks["build_app_${lch}"].mustRunAfter copy_resources, prepare_project, clean_project
  tasks["build_test_${lch}"].mustRunAfter copy_resources, prepare_project, clean_project
  tasks["run_test_${lch}"].mustRunAfter copy_resources, prepare_project, clean_project, tasks["build_test_${lch}"]

  build_app_tasks << tasks["build_app_${lch}"]
  build_test_tasks << tasks["build_test_${lch}"]
  run_test_tasks << tasks["run_test_${lch}"]
}

task clean_all {
  group = "clean"
  dependsOn { [clean_submodules, clean_project] }
}

task build_all {
  group = "build"
  dependsOn { [update_submodules, build_submodules, prepare_project, copy_resources] + build_app_tasks }
}

task test_all {
  group = "run"
  dependsOn { [update_submodules, build_submodules, prepare_project, copy_resources] + build_test_tasks + run_test_tasks }
}

defaultTasks 'build_all'
